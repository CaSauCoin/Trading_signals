from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
import sys
import os

# Add the correct path to AdvancedSMC
# Navigate from current file to the AdvancedSMC directory
current_dir = os.path.dirname(__file__)  # handlers directory
src_dir = os.path.dirname(os.path.dirname(current_dir))  # src directory
telegram_bot_dir = os.path.dirname(src_dir)  # telegram_bot directory
backend_dir = os.path.dirname(telegram_bot_dir)  # backend directory
advancedSMC_path = os.path.join(backend_dir, 'AdvancedSMC')
sys.path.insert(0, advancedSMC_path)

try:
    from AdvancedSMC import AdvancedSMC
    SMC_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import AdvancedSMC: {e}")
    SMC_AVAILABLE = False
    AdvancedSMC = None

# Initialize analysis service if available
if SMC_AVAILABLE and AdvancedSMC:
    try:
        analysis_service = AdvancedSMC()
        print("AdvancedSMC initialized successfully")
    except Exception as e:
        print(f"Error initializing AdvancedSMC: {e}")
        analysis_service = None
else:
    analysis_service = None

def handle_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    
    user_id = update.effective_user.id
    data = query.data
    
    # Initialize user states if not exists
    if not hasattr(context.bot_data, 'user_states'):
        context.bot_data['user_states'] = {}
    
    # Route callbacks
    if data == 'custom_token':
        handle_custom_token_callback(query, context, user_id)
    elif data.startswith('analyze_'):
        handle_analyze_callback(query, context, data)
    elif data == 'select_pair':
        handle_select_pair_callback(query, context)
    elif data == 'watchlist_menu':
        show_watchlist_menu(query, context)
    elif data.startswith('watchlist_'):
        handle_watchlist_callback(query, context, data)
    elif data.startswith('timeframe_'):
        handle_timeframe_callback(query, context, data)
    elif data.startswith('refresh_'):
        handle_refresh_callback(query, context, data)
    elif data == 'back_to_main':
        handle_back_to_main(query, context)
    elif data == 'help':
        show_help(query)
    else:
        query.edit_message_text("‚ö†Ô∏è Ch·ª©c nƒÉng ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...")

def handle_custom_token_callback(query, context, user_id):
    """Handle custom token input callback"""
    context.bot_data['user_states'][user_id] = {"waiting_for": "custom_token"}
    query.edit_message_text(
        "‚úèÔ∏è **Nh·∫≠p token t√πy ch·ªânh**\n\n"
        "G·ª≠i t√™n token b·∫°n mu·ªën ph√¢n t√≠ch:\n"
        "‚Ä¢ V√≠ d·ª•: BTC, ETH, PEPE\n"
        "‚Ä¢ Ho·∫∑c c·∫∑p: BTC/USDT, ETH/USDT\n\n"
        "üí° H·ªó tr·ª£ t·∫•t c·∫£ token tr√™n Binance!",
        parse_mode='Markdown'
    )

def handle_analyze_callback(query, context, data):
    """Handle analysis callback"""
    parts = data.split('_')
    if len(parts) >= 3:
        symbol = '_'.join(parts[1:-1])  # Handle symbols with underscores
        timeframe = parts[-1]
    else:
        symbol = parts[1] if len(parts) > 1 else 'BTC/USDT'
        timeframe = '4h'
    
    perform_analysis_callback(query, context, symbol, timeframe)

def handle_select_pair_callback(query, context):
    """Handle select pair callback"""
    keyboard = [
        [InlineKeyboardButton("BTC/USDT", callback_data='analyze_BTC/USDT_4h'),
         InlineKeyboardButton("ETH/USDT", callback_data='analyze_ETH/USDT_4h')],
        [InlineKeyboardButton("BNB/USDT", callback_data='analyze_BNB/USDT_4h'),
         InlineKeyboardButton("ADA/USDT", callback_data='analyze_ADA/USDT_4h')],
        [InlineKeyboardButton("SOL/USDT", callback_data='analyze_SOL/USDT_4h'),
         InlineKeyboardButton("DOT/USDT", callback_data='analyze_DOT/USDT_4h')],
        [InlineKeyboardButton("MATIC/USDT", callback_data='analyze_MATIC/USDT_4h'),
         InlineKeyboardButton("AVAX/USDT", callback_data='analyze_AVAX/USDT_4h')],
        [InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        "üîç **Ch·ªçn c·∫∑p token ph·ªï bi·∫øn:**",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

def handle_timeframe_callback(query, context, data):
    """Handle timeframe selection callback"""
    symbol = data.replace('timeframe_', '')
    
    keyboard = [
        [InlineKeyboardButton("15m", callback_data=f'analyze_{symbol}_15m'),
         InlineKeyboardButton("1h", callback_data=f'analyze_{symbol}_1h')],
        [InlineKeyboardButton("4h", callback_data=f'analyze_{symbol}_4h'),
         InlineKeyboardButton("1d", callback_data=f'analyze_{symbol}_1d')],
        [InlineKeyboardButton("3d", callback_data=f'analyze_{symbol}_3d'),
         InlineKeyboardButton("1w", callback_data=f'analyze_{symbol}_1w')],
        [InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        f"‚è±Ô∏è **Ch·ªçn timeframe cho {symbol}:**",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

def handle_refresh_callback(query, context, data):
    """Handle refresh analysis callback"""
    parts = data.replace('refresh_', '').split('_')
    symbol = '_'.join(parts[:-1])
    timeframe = parts[-1]
    
    perform_analysis_callback(query, context, symbol, timeframe)

def perform_analysis_callback(query, context, symbol: str, timeframe: str):
    """Perform analysis and update message"""
    # Show loading
    query.edit_message_text(f"üîÑ **ƒêang ph√¢n t√≠ch {symbol} {timeframe}...**", parse_mode='Markdown')
    
    try:
        # Check if analysis service is available
        if not analysis_service:
            query.edit_message_text(
                f"‚ùå **L·ªói h·ªá th·ªëng**\n\n"
                f"AdvancedSMC service kh√¥ng kh·∫£ d·ª•ng.",
                parse_mode='Markdown'
            )
            return
        
        # Perform analysis using AdvancedSMC
        result = analyze_with_smc(symbol, timeframe)
        
        if result.get('error'):
            query.edit_message_text(
                f"‚ùå **L·ªói ph√¢n t√≠ch {symbol}**\n\n"
                f"Chi ti·∫øt: {result.get('message', 'Unknown error')}",
                parse_mode='Markdown'
            )
            return
        
        # Format results
        formatted_result = format_analysis_result(result)
        
        # Create action buttons
        keyboard = [
            [InlineKeyboardButton("‚ûï Th√™m v√†o Watchlist", callback_data=f'watchlist_add_{symbol}_{timeframe}')],
            [InlineKeyboardButton("üîÑ L√†m m·ªõi", callback_data=f'refresh_{symbol}_{timeframe}')],
            [InlineKeyboardButton("‚è±Ô∏è ƒê·ªïi timeframe", callback_data=f'timeframe_{symbol}')],
            [InlineKeyboardButton("üîô Menu ch√≠nh", callback_data='back_to_main')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        query.edit_message_text(formatted_result, reply_markup=reply_markup, parse_mode='Markdown')
        
    except Exception as e:
        query.edit_message_text(
            f"‚ùå **L·ªói ph√¢n t√≠ch {symbol}**\n\n"
            f"Chi ti·∫øt: {str(e)}",
            parse_mode='Markdown'
        )

def analyze_with_smc(symbol: str, timeframe: str):
    """Analyze symbol using AdvancedSMC"""
    try:
        if not analysis_service:
            return {
                'error': True,
                'message': 'AdvancedSMC service not available'
            }
        
        # Normalize symbol format for Binance
        if '/' not in symbol and not symbol.endswith('USDT'):
            symbol = f"{symbol}USDT"
        elif '/' in symbol:
            symbol = symbol.replace('/', '')
        
        print(f"Analyzing {symbol} {timeframe} with AdvancedSMC...")
        
        # Call your AdvancedSMC methods here
        # Adjust these method names based on your actual AdvancedSMC class
        
        # Example calls (you need to replace with actual method names):
        # order_blocks = analysis_service.get_order_blocks(symbol, timeframe)
        # fvg = analysis_service.get_fair_value_gaps(symbol, timeframe)
        # bos = analysis_service.get_break_of_structure(symbol, timeframe)
        # signal = analysis_service.get_trading_signal(symbol, timeframe)
        
        # For now, return mock data - replace with actual analysis
        result = {
            'error': False,
            'symbol': symbol,
            'timeframe': timeframe,
            'analysis': {
                'signal': {'signal': 'BUY', 'confidence': 75},
                'order_blocks': {'status': 'Bullish OB found', 'count': 2},
                'fair_value_gaps': {'status': 'FVG detected', 'direction': 'bullish'},
                'break_of_structure': {'status': 'BOS confirmed', 'direction': 'up'},
                'liquidity_zones': {'status': 'Liquidity swept', 'level': 'high'},
                'timestamp': '2025-08-26T15:30:00'
            }
        }
        
        return result
        
    except Exception as e:
        print(f"Error in SMC analysis: {e}")
        return {
            'error': True,
            'message': f'Analysis failed: {str(e)}'
        }

def handle_watchlist_callback(query, context, data):
    """Handle watchlist related callbacks"""
    if data == 'watchlist_add':
        user_id = query.from_user.id
        context.bot_data['user_states'][user_id] = {"waiting_for": "watchlist_add"}
        query.edit_message_text(
            "‚ûï **Th√™m token v√†o Watchlist**\n\n"
            "G·ª≠i t√™n token b·∫°n mu·ªën theo d√µi:\n"
            "‚Ä¢ V√≠ d·ª•: BTC, ETH, PEPE\n"
            "‚Ä¢ Ho·∫∑c c·∫∑p: BTC/USDT, ETH/USDT\n\n"
            "üí° S·∫Ω s·ª≠ d·ª•ng timeframe 4h m·∫∑c ƒë·ªãnh.",
            parse_mode='Markdown'
        )
    elif data.startswith('watchlist_add_'):
        # Extract symbol and timeframe from callback
        parts = data.replace('watchlist_add_', '').split('_')
        symbol = '_'.join(parts[:-1])
        timeframe = parts[-1]
        add_to_watchlist_callback(query, context, symbol, timeframe)
    else:
        query.edit_message_text("‚ö†Ô∏è Ch·ª©c nƒÉng watchlist ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...")

def add_to_watchlist_callback(query, context, symbol: str, timeframe: str):
    """Add token to watchlist via callback"""
    # TODO: Implement actual watchlist storage
    query.edit_message_text(
        f"‚úÖ **ƒê√£ th√™m {symbol} ({timeframe}) v√†o watchlist!**\n\n"
        "üìã S·ª≠ d·ª•ng menu Watchlist ƒë·ªÉ qu·∫£n l√Ω danh s√°ch theo d√µi.",
        parse_mode='Markdown'
    )

def handle_back_to_main(query, context):
    """Handle back to main menu"""
    keyboard = [
        [InlineKeyboardButton("üìä Ph√¢n t√≠ch BTC/USDT", callback_data='analyze_BTC/USDT_4h')],
        [InlineKeyboardButton("üìà Ph√¢n t√≠ch ETH/USDT", callback_data='analyze_ETH/USDT_4h')],
        [InlineKeyboardButton("üîç Ch·ªçn c·∫∑p c√≥ s·∫µn", callback_data='select_pair')],
        [InlineKeyboardButton("‚úèÔ∏è Nh·∫≠p token t√πy ch·ªânh", callback_data='custom_token')],
        [InlineKeyboardButton("üëÅÔ∏è Danh s√°ch theo d√µi", callback_data='watchlist_menu')],
        [InlineKeyboardButton("‚ÑπÔ∏è H∆∞·ªõng d·∫´n", callback_data='help')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    welcome_text = """
üöÄ **Trading Bot SMC!**

Ch·ªçn m·ªôt t√πy ch·ªçn b√™n d∆∞·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu:

üí° **M·ªõi:** 
‚Ä¢ Nh·∫≠p b·∫•t k·ª≥ token n√†o tr√™n Binance!
‚Ä¢ Theo d√µi t·ª± ƒë·ªông v·ªõi c·∫≠p nh·∫≠t m·ªói gi·ªù!
    """
    
    query.edit_message_text(welcome_text, reply_markup=reply_markup, parse_mode='Markdown')

def format_analysis_result(result: dict) -> str:
    """Format analysis results for display"""
    if result.get('error'):
        return f"‚ùå **L·ªói:** {result.get('message')}"
    
    symbol = result.get('symbol', 'Unknown')
    timeframe = result.get('timeframe', '4h')
    analysis = result.get('analysis', {})
    
    # Extract analysis data
    signal = analysis.get('signal', {})
    order_blocks = analysis.get('order_blocks', {})
    fvg = analysis.get('fair_value_gaps', {})
    bos = analysis.get('break_of_structure', {})
    liquidity = analysis.get('liquidity_zones', {})
    
    # Format signal emoji
    signal_emoji = "üü¢" if signal.get('signal') == 'BUY' else "üî¥" if signal.get('signal') == 'SELL' else "üü°"
    
    # Format the message
    formatted_msg = f"""
üìä **Ph√¢n t√≠ch SMC: {symbol} ({timeframe})**

{signal_emoji} **T√≠n hi·ªáu:** {signal.get('signal', 'NEUTRAL')}
üìà **ƒê·ªô tin c·∫≠y:** {signal.get('confidence', 0)}%

üî≤ **Order Blocks:** {order_blocks.get('status', 'N/A')}
‚ö° **Fair Value Gaps:** {fvg.get('status', 'N/A')}
üìä **Break of Structure:** {bos.get('status', 'N/A')}
üíß **Liquidity Zones:** {liquidity.get('status', 'N/A')}

‚è∞ **C·∫≠p nh·∫≠t:** {analysis.get('timestamp', 'N/A')}

‚ö†Ô∏è *Ch·ªâ mang t√≠nh ch·∫•t tham kh·∫£o, kh√¥ng ph·∫£i l·ªùi khuy√™n ƒë·∫ßu t∆∞.*
    """
    
    return formatted_msg.strip()

def show_watchlist_menu(query, context):
    """Show watchlist management menu"""
    keyboard = [
        [InlineKeyboardButton("‚ûï Th√™m token", callback_data='watchlist_add')],
        [InlineKeyboardButton("üìã Xem danh s√°ch", callback_data='watchlist_view')],
        [InlineKeyboardButton("üóëÔ∏è X√≥a token", callback_data='watchlist_remove')],
        [InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        "üëÅÔ∏è **Qu·∫£n l√Ω Watchlist**\n\n"
        "‚Ä¢ T·ªëi ƒëa 5 tokens\n"
        "‚Ä¢ C·∫≠p nh·∫≠t t·ª± ƒë·ªông m·ªói gi·ªù\n"
        "‚Ä¢ Th√¥ng b√°o khi c√≥ t√≠n hi·ªáu\n\n"
        "Ch·ªçn h√†nh ƒë·ªông:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

def show_help(query):
    """Show help information"""
    help_text = """
‚ÑπÔ∏è **H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Trading Bot SMC**

**üéØ T√≠nh nƒÉng ch√≠nh:**
‚Ä¢ Ph√¢n t√≠ch SMC (Smart Money Concepts)
‚Ä¢ Order Blocks, Fair Value Gaps
‚Ä¢ Break of Structure, Liquidity Zones
‚Ä¢ Watchlist t·ª± ƒë·ªông c·∫≠p nh·∫≠t

**üì± C√°ch s·ª≠ d·ª•ng:**
1Ô∏è‚É£ Ch·ªçn token t·ª´ menu
2Ô∏è‚É£ Ho·∫∑c nh·∫≠p token t√πy ch·ªânh
3Ô∏è‚É£ Xem k·∫øt qu·∫£ ph√¢n t√≠ch
4Ô∏è‚É£ Th√™m v√†o watchlist n·∫øu mu·ªën

**‚ö° L·ªánh nhanh:**
‚Ä¢ /start - Hi·ªÉn th·ªã menu
‚Ä¢ /analysis BTC/USDT 4h - Ph√¢n t√≠ch tr·ª±c ti·∫øp

**‚ö†Ô∏è L∆∞u √Ω:**
Bot ch·ªâ h·ªó tr·ª£ ph√¢n t√≠ch, kh√¥ng ph·∫£i l·ªùi khuy√™n ƒë·∫ßu t∆∞.
    """
    
    keyboard = [[InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_main')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode='Markdown')